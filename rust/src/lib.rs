#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]

/// Aliased type for any errors related to ukv. Since the type
/// of [bindings::ukv_error_t] is a raw [std::ffi::c_char] pointer,
/// there is no specific way to track the errors more efficiently.
pub type Error<'a> = std::borrow::Cow<'a, str>;

/// Bindings generated by bindgen for the ukv library. Only use this
/// module directly if you know what you are doing.
pub mod bindings {
	include!(concat!(env!("OUT_DIR"), "/bindings.rs"));
}

/// Provides a safe interface for working with [bindings::ukv_database_init_t].
#[derive(Debug)]
pub struct Database {
	/// Internal object will be used for safely interfacing with the
	/// C/C++ bindings via a Rust-defined interface.
	inner: bindings::ukv_database_init_t,
}

/// Provides a _fallible_ initialization interface for [Database]. Prefer
/// using [Database::new] for error-safe initialization. You should always
/// check for errors after initialization by calling [Database::error] in
/// case something fails.
impl Default for Database {
	fn default() -> Self {
		let mut inner = bindings::ukv_database_init_t {
			db: &mut () as *mut _ as *mut std::ffi::c_void as _,
			config: std::ffi::CString::default().as_ptr() as *const _,
			error: &mut std::ffi::CString::default().as_ptr() as *mut _,
		};

		unsafe { bindings::ukv_database_init(&mut inner) };
		Self {
			inner,
		}
	}
}

impl<'a> Database {
	/// Creates a new [Database] instance. In case of errors, the
	/// function will return [Error].
	pub fn new() -> Result<Self, Error<'a>> {
		let initialized: Database = Default::default();
		initialized.error()?;
		Ok(initialized)
	}

	/// Checks whether there are any errors created by the database,
	/// and returns the pointer to the error.
	pub fn error(&self) -> Result<(), Error<'a>> {
		if !self.inner.error.is_null() {
			// We know that `error` is going to be a valid pointer, pointing to a
			// std::ffi::CString, thus, dereferencing the pointer here is safe.
			let message = unsafe { std::ffi::CStr::from_ptr(*self.inner.error) };
			return Err(String::from_utf8_lossy(message.to_bytes()));
		}

		Ok(())
	}

	/// Closes a [Database] instance. In case of errors, the function
	/// will return [Error].
	#[inline]
	pub fn close(self) -> Result<(), Error<'a>> {
		// We know that `self.inner.db` is going to point to a valid address
		// in memory, thus, dereferencing the pointer here is safe.
		unsafe { bindings::ukv_database_free(*self.inner.db) };
		Ok(self.error()?)
	}
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_Database_new() {
		assert!(Database::new().is_ok());
	}

	#[test]
	fn test_Database_default() {
		assert!(Database::default().error().is_ok())
	}

	#[test]
	fn test_Database_close() {
		let database = Database::new().expect("Cannot initialize the database");
		assert!(database.close().is_ok())
	}
}
